from __future__ import annotations

from flask import (
    Blueprint,
    abort,
    flash,
    jsonify,
    redirect,
    render_template,
    request,
    session,
    url_for,
)
from flask_login import current_user, login_required
from flask_wtf.csrf import validate_csrf

from app import db
from app.forms import (
    ConfirmForm,
    DeleteForm,
    PurchaseOrderForm,
    PurchaseOrderMergeForm,
    ReceiveInvoiceForm,
    VendorItemAliasResolutionForm,
    load_purchase_gl_code_choices,
)
from app.models import (
    GLCode,
    Item,
    ItemUnit,
    Location,
    LocationStandItem,
    PurchaseInvoice,
    PurchaseInvoiceDraft,
    PurchaseInvoiceItem,
    PurchaseOrder,
    PurchaseOrderItem,
    PurchaseOrderItemArchive,
    Setting,
    Vendor,
)
from app.utils.activity import log_activity
from app.utils.numeric import coerce_float
from app.routes.report_routes import (
    _invoice_gl_code_rows,
    invoice_gl_code_report,
)
from app.utils.forecasting import DemandForecastingHelper
from app.utils.pagination import build_pagination_args, get_per_page
from app.services.purchase_merge import (
    PurchaseMergeError,
    merge_purchase_orders,
)
from app.services.purchase_imports import (
    CSVImportError,
    parse_purchase_order_csv,
    resolve_vendor_purchase_lines,
    serialize_parsed_line,
    update_or_create_vendor_alias,
)

import datetime
import json
import re

from sqlalchemy import func, or_
from sqlalchemy.orm import selectinload
from wtforms.validators import ValidationError

purchase = Blueprint("purchase", __name__)


_PURCHASE_UPLOAD_SESSION_KEY = "purchase_order_upload"


def _get_enabled_import_vendors():
    def _normalize_label(label: str | None) -> str | None:
        if not label:
            return None
        normalized = label.strip()
        if not normalized:
            return None
        return normalized.upper()

    enabled_labels = {
        normalized
        for normalized in (
            _normalize_label(name) for name in Setting.get_enabled_purchase_import_vendors()
        )
        if normalized
    }
    if not enabled_labels:
        enabled_labels = {
            normalized
            for normalized in (
                _normalize_label(name) for name in Setting.DEFAULT_PURCHASE_IMPORT_VENDORS
            )
            if normalized
        }

    def _vendor_labels(vendor: Vendor) -> set[str]:
        labels: set[str] = set()
        first = _normalize_label(vendor.first_name)
        last = _normalize_label(vendor.last_name)

        if first:
            labels.add(first)
        if last:
            labels.add(last)
        if first and last:
            labels.add(f"{first} {last}")

        return labels

    return [
        vendor
        for vendor in Vendor.query.filter_by(archived=False).all()
        if _vendor_labels(vendor) & enabled_labels
    ]


def _merge_error_response(message: str, wants_json: bool):
    if wants_json:
        return jsonify({"error": message}), 400
    flash(message, "error")
    return redirect(url_for("purchase.view_purchase_orders"))


def _clear_purchase_upload_state():
    session.pop(_PURCHASE_UPLOAD_SESSION_KEY, None)


def _get_purchase_upload_state() -> dict | None:
    state = session.get(_PURCHASE_UPLOAD_SESSION_KEY)
    if not isinstance(state, dict):
        return None
    return state


def _parse_source_ids(raw_source_ids) -> list[int]:
    source_ids: list[int] = []
    if isinstance(raw_source_ids, str):
        tokens = [t.strip() for t in re.split(r"[\s,]+", raw_source_ids) if t.strip()]
    else:
        tokens = raw_source_ids or []

    for token in tokens:
        try:
            parsed = int(token)
        except (TypeError, ValueError):
            raise PurchaseMergeError(f"Invalid purchase order ID: {token}")
        if parsed <= 0:
            raise PurchaseMergeError("Purchase order IDs must be positive numbers.")
        if parsed not in source_ids:
            source_ids.append(parsed)

    if not source_ids:
        raise PurchaseMergeError("Please provide at least one source purchase order ID.")

    return source_ids


def _validate_json_csrf(payload: dict | None) -> None:
    token = request.headers.get("X-CSRFToken")
    if not token and payload:
        token = payload.get("csrf_token")

    if not token:
        raise PurchaseMergeError("Missing CSRF token for merge request.")

    try:
        validate_csrf(token)
    except ValidationError as exc:
        raise PurchaseMergeError(f"CSRF validation failed: {exc}") from exc


def _purchase_gl_code_choices():
    return (
        GLCode.query.filter(
            or_(GLCode.code.like("5%"), GLCode.code.like("6%"))
        )
        .order_by(GLCode.code)
        .all()
    )


def check_negative_invoice_reverse(invoice_obj):
    """Return warnings if reversing the invoice would cause negative inventory."""
    warnings = []
    for inv_item in invoice_obj.items:
        factor = 1
        if inv_item.unit_id:
            unit = db.session.get(ItemUnit, inv_item.unit_id)
            if unit:
                factor = unit.factor
        itm = db.session.get(Item, inv_item.item_id)
        if itm:
            loc_id = inv_item.location_id or invoice_obj.location_id
            record = LocationStandItem.query.filter_by(
                location_id=loc_id,
                item_id=itm.id,
            ).first()
            current = record.expected_count if record else 0
            new_count = current - inv_item.quantity * factor
            if new_count < 0:
                if record and record.location:
                    location_name = record.location.name
                else:
                    fallback_location = db.session.get(Location, loc_id)
                    if fallback_location:
                        location_name = fallback_location.name
                    else:
                        location_name = invoice_obj.location_name
                warnings.append(
                    f"Reversing this invoice will result in negative inventory for {itm.name} at {location_name}"
                )
        else:
            warnings.append(
                f"Cannot reverse invoice because item '{inv_item.item_name}' no longer exists"
            )
    return warnings


@purchase.route("/purchase_orders", methods=["GET"])
@login_required
def view_purchase_orders():
    """Show purchase orders with optional filters."""
    delete_form = DeleteForm()
    merge_form = PurchaseOrderMergeForm()
    page = request.args.get("page", 1, type=int)
    per_page = get_per_page()
    vendor_id = request.args.get("vendor_id", type=int)
    status = request.args.get("status", "pending")
    start_date_str = request.args.get("start_date")
    end_date_str = request.args.get("end_date")
    raw_item_ids = request.args.getlist("item_id")

    item_ids = []
    for raw_id in raw_item_ids:
        try:
            parsed_id = int(raw_id)
        except (TypeError, ValueError):
            continue
        if parsed_id <= 0 or parsed_id in item_ids:
            continue
        item_ids.append(parsed_id)

    selected_items = []
    if item_ids:
        selected_item_records = Item.query.filter(Item.id.in_(item_ids)).all()
        item_lookup = {item.id: item for item in selected_item_records}
        item_ids = [item_id for item_id in item_ids if item_id in item_lookup]
        selected_items = [item_lookup[item_id] for item_id in item_ids]

    start_date = (
        datetime.datetime.strptime(start_date_str, "%Y-%m-%d").date()
        if start_date_str
        else None
    )
    end_date = (
        datetime.datetime.strptime(end_date_str, "%Y-%m-%d").date()
        if end_date_str
        else None
    )

    query = PurchaseOrder.query

    if status == "pending":
        query = query.filter_by(received=False)
    elif status == "completed":
        query = query.filter_by(received=True)

    if item_ids:
        query = query.filter(
            PurchaseOrder.items.any(
                PurchaseOrderItem.item_id.in_(item_ids)
            )
        )

    if vendor_id:
        query = query.filter(PurchaseOrder.vendor_id == vendor_id)
    if start_date:
        query = query.filter(PurchaseOrder.order_date >= start_date)
    if end_date:
        query = query.filter(PurchaseOrder.order_date <= end_date)

    query = query.options(
        selectinload(PurchaseOrder.vendor),
        selectinload(PurchaseOrder.items).selectinload(PurchaseOrderItem.item),
        selectinload(PurchaseOrder.items).selectinload(PurchaseOrderItem.product),
        selectinload(PurchaseOrder.items).selectinload(PurchaseOrderItem.unit),
    )

    orders = query.order_by(PurchaseOrder.order_date.desc()).paginate(
        page=page, per_page=per_page
    )

    vendors = Vendor.query.filter_by(archived=False).all()
    upload_vendors = _get_enabled_import_vendors()
    filter_items = (
        Item.query.filter_by(archived=False)
        .order_by(Item.name)
        .all()
    )
    active_item_ids = {item.id for item in filter_items}
    extra_item_options = [
        item for item in selected_items if item.id not in active_item_ids
    ]
    selected_vendor = db.session.get(Vendor, vendor_id) if vendor_id else None
    return render_template(
        "purchase_orders/view_purchase_orders.html",
        orders=orders,
        delete_form=delete_form,
        merge_form=merge_form,
        vendors=vendors,
        upload_vendors=upload_vendors,
        vendor_id=vendor_id,
        start_date=start_date_str,
        end_date=end_date_str,
        status=status,
        selected_vendor=selected_vendor,
        filter_items=filter_items,
        extra_item_options=extra_item_options,
        selected_item_ids=item_ids,
        selected_items=selected_items,
        per_page=per_page,
        pagination_args=build_pagination_args(per_page),
    )


@purchase.route("/purchase_orders/merge", methods=["POST"])
@login_required
def merge_purchase_orders_route():
    """Merge unreceived purchase orders into a single target order."""

    wants_json = request.is_json or request.accept_mimetypes.best == "application/json"
    payload = request.get_json(silent=True) if request.is_json else None
    if payload is None and request.is_json:
        payload = {}

    form = PurchaseOrderMergeForm()
    if not request.is_json and not form.validate_on_submit():
        flash("Invalid merge request. Please check the form inputs.", "error")
        return redirect(url_for("purchase.view_purchase_orders"))

    if request.is_json:
        try:
            _validate_json_csrf(payload)
        except PurchaseMergeError as exc:
            return jsonify({"error": str(exc)}), 400
        target_po_id = payload.get("target_po_id")
        raw_source_ids = payload.get("source_po_ids", [])
    else:
        target_po_id = form.target_po_id.data
        raw_source_ids = form.source_po_ids.data or ""

    try:
        target_id = int(target_po_id)
    except (TypeError, ValueError):
        return _merge_error_response(
            "Target purchase order ID is required.", wants_json
        )

    if target_id <= 0:
        return _merge_error_response(
            "Target purchase order ID must be a positive number.", wants_json
        )

    try:
        source_ids = _parse_source_ids(raw_source_ids)
    except PurchaseMergeError as exc:
        return _merge_error_response(str(exc), wants_json)

    try:
        merge_purchase_orders(
            target_po_id=target_id,
            source_po_ids=source_ids,
        )
    except PurchaseMergeError as exc:
        return _merge_error_response(f"Merge failed: {exc}", wants_json)
    except Exception:
        return _merge_error_response(
            "An unexpected error occurred while merging purchase orders.", wants_json
        )

    success_message = (
        f"Merged purchase orders {', '.join(map(str, source_ids))} into {target_id}."
    )
    if wants_json:
        return (
            jsonify(
                {
                    "message": success_message,
                    "target_po_id": target_id,
                    "merged_po_ids": source_ids,
                }
            ),
            200,
        )

    flash(success_message, "success")
    return redirect(url_for("purchase.view_purchase_orders"))


@purchase.route("/purchase_orders/upload", methods=["POST"])
@login_required
def upload_purchase_order():
    file = request.files.get("purchase_order_file")
    vendor_id = request.form.get("vendor_id", type=int)
    vendor = db.session.get(Vendor, vendor_id) if vendor_id else None
    enabled_vendor_ids = {vendor.id for vendor in _get_enabled_import_vendors()}

    if vendor is None or vendor.archived or vendor.id not in enabled_vendor_ids:
        flash("Select an enabled vendor before uploading a purchase order file.", "danger")
        return redirect(url_for("purchase.view_purchase_orders"))

    try:
        parsed_order = parse_purchase_order_csv(file, vendor)
        resolved_lines = resolve_vendor_purchase_lines(vendor, parsed_order.items)
    except CSVImportError as exc:
        flash(str(exc), "danger")
        return redirect(url_for("purchase.view_purchase_orders"))

    payload = {
        "vendor_id": vendor.id,
        "vendor_name": f"{vendor.first_name} {vendor.last_name}",
        "source_filename": getattr(file, "filename", None),
        "order_number": parsed_order.order_number,
        "order_date": parsed_order.order_date.isoformat()
        if parsed_order.order_date
        else None,
        "expected_date": parsed_order.expected_date.isoformat()
        if parsed_order.expected_date
        else None,
        "expected_total": parsed_order.expected_total,
        "items": [],
    }

    for idx, resolved in enumerate(resolved_lines):
        payload["items"].append(
            {
                "index": idx,
                **serialize_parsed_line(resolved.parsed_line),
                "item_id": resolved.item_id,
                "unit_id": resolved.unit_id,
                "cost": resolved.cost,
            }
        )

    session[_PURCHASE_UPLOAD_SESSION_KEY] = payload
    session.modified = True

    unresolved_count = len([line for line in payload["items"] if not line.get("item_id")])
    if unresolved_count:
        flash(
            "We need your help matching a few vendor items before creating the purchase order.",
            "warning",
        )
        return redirect(url_for("purchase.resolve_vendor_items"))

    flash("Purchase order parsed successfully. Review the prefilled form to continue.", "success")
    return redirect(url_for("purchase.create_purchase_order"))


@purchase.route("/purchase_orders/resolve_vendor_items", methods=["GET", "POST"])
@login_required
def resolve_vendor_items():
    payload = _get_purchase_upload_state()
    if not payload:
        flash("Upload a purchase order file to start resolving vendor items.", "warning")
        return redirect(url_for("purchase.create_purchase_order"))

    unresolved_lines = [line for line in payload.get("items", []) if not line.get("item_id")]
    if not unresolved_lines:
        return redirect(url_for("purchase.create_purchase_order"))

    vendor = db.session.get(Vendor, payload.get("vendor_id")) if payload.get("vendor_id") else None
    if vendor is None:
        flash("The selected vendor could not be found.", "danger")
        _clear_purchase_upload_state()
        return redirect(url_for("purchase.create_purchase_order"))

    form = VendorItemAliasResolutionForm()
    form.vendor_id.data = vendor.id
    form.order_date.data = payload.get("order_date")
    form.expected_date.data = payload.get("expected_date")
    form.order_number.data = payload.get("order_number")
    form.expected_total_cost.data = payload.get("expected_total")
    form.parsed_payload.data = json.dumps(payload)
    form.unresolved_payload.data = json.dumps(unresolved_lines)

    form.rows.min_entries = len(unresolved_lines)
    while len(form.rows) < len(unresolved_lines):
        form.rows.append_entry()

    items = (
        Item.query.options(selectinload(Item.units))
        .filter_by(archived=False)
        .order_by(Item.name)
        .all()
    )
    item_choices = [(item.id, item.name) for item in items]
    units_map = {item.id: [(unit.id, unit.name) for unit in item.units] for item in items}

    for idx, row_form in enumerate(form.rows):
        parsed = unresolved_lines[idx]
        if request.method == "GET":
            row_form.vendor_sku.data = parsed.get("vendor_sku")
            row_form.vendor_description.data = parsed.get("vendor_description")
            row_form.pack_size.data = parsed.get("pack_size")
            row_form.quantity.data = parsed.get("quantity")
            row_form.unit_cost.data = parsed.get("unit_cost")

        row_form.item_id.choices = item_choices
        selected_item = row_form.item_id.data or None
        row_form.unit_id.choices = [(0, "â€”")] + units_map.get(selected_item, [])

    if form.validate_on_submit():
        unresolved_targets = [line for line in payload.get("items", []) if not line.get("item_id")]

        for idx, row_form in enumerate(form.rows):
            parsed = unresolved_targets[idx] if idx < len(unresolved_targets) else None
            if parsed is None:
                continue

            unit_id = row_form.unit_id.data or None
            alias = update_or_create_vendor_alias(
                vendor=vendor,
                item_id=row_form.item_id.data,
                item_unit_id=unit_id,
                vendor_sku=parsed.get("vendor_sku"),
                vendor_description=parsed.get("vendor_description"),
                pack_size=parsed.get("pack_size"),
                default_cost=coerce_float(parsed.get("unit_cost")),
            )
            db.session.add(alias)

            parsed["item_id"] = row_form.item_id.data
            parsed["unit_id"] = unit_id

        db.session.commit()
        session[_PURCHASE_UPLOAD_SESSION_KEY] = payload
        session.modified = True

        flash("Vendor item mappings saved. Review the purchase order details next.", "success")
        return redirect(url_for("purchase.create_purchase_order"))

    gl_codes = _purchase_gl_code_choices()
    return render_template(
        "purchase_orders/resolve_vendor_items.html",
        form=form,
        vendor=vendor,
        unresolved_lines=unresolved_lines,
        units_map=units_map,
        source_filename=payload.get("source_filename"),
        gl_codes=gl_codes,
    )


@purchase.route("/purchase_orders/create", methods=["GET", "POST"])
@login_required
def create_purchase_order():
    """Create a purchase order."""
    form = PurchaseOrderForm()
    upload_state = _get_purchase_upload_state()

    if request.args.get("reset_upload"):
        _clear_purchase_upload_state()
        return redirect(url_for("purchase.create_purchase_order"))

    if upload_state and any(not line.get("item_id") for line in upload_state.get("items", [])):
        return redirect(url_for("purchase.resolve_vendor_items"))

    if request.method == "GET":
        seed = session.pop("po_recommendation_seed", None)
        if seed:
            vendor_id = seed.get("vendor_id")
            if vendor_id and vendor_id in [choice[0] for choice in form.vendor.choices]:
                form.vendor.data = vendor_id
            order_date = seed.get("order_date")
            expected_date = seed.get("expected_date")
            if order_date:
                try:
                    form.order_date.data = datetime.datetime.strptime(
                        order_date, "%Y-%m-%d"
                    ).date()
                except ValueError:
                    form.order_date.data = datetime.date.today()
            if expected_date:
                try:
                    form.expected_date.data = datetime.datetime.strptime(
                        expected_date, "%Y-%m-%d"
                    ).date()
                except ValueError:
                    form.expected_date.data = datetime.date.today() + datetime.timedelta(
                        days=1
                    )

            items = seed.get("items", [])
            form.items.min_entries = max(len(items), 1)
            while len(form.items) < len(items):
                form.items.append_entry()
            for idx, entry in enumerate(items):
                if idx >= len(form.items):
                    break
                form.items[idx].item.data = entry.get("item_id")
                form.items[idx].unit.data = entry.get("unit_id")
                form.items[idx].quantity.data = entry.get("quantity")
                form.items[idx].position.data = idx

        if upload_state:
            vendor_id = upload_state.get("vendor_id")
            if vendor_id and vendor_id in [choice[0] for choice in form.vendor.choices]:
                form.vendor.data = vendor_id

            if upload_state.get("order_number"):
                form.order_number.data = upload_state.get("order_number")
            if upload_state.get("expected_total") is not None:
                form.expected_total_cost.data = upload_state.get("expected_total")
            if upload_state.get("order_date"):
                try:
                    form.order_date.data = datetime.date.fromisoformat(
                        upload_state.get("order_date")
                    )
                except ValueError:
                    form.order_date.data = datetime.date.today()
            if upload_state.get("expected_date"):
                try:
                    form.expected_date.data = datetime.date.fromisoformat(
                        upload_state.get("expected_date")
                    )
                except ValueError:
                    form.expected_date.data = datetime.date.today() + datetime.timedelta(
                        days=1
                    )

            parsed_items = [
                line for line in upload_state.get("items", []) if line.get("item_id")
            ]
            form.items.min_entries = max(len(parsed_items), form.items.min_entries)
            while len(form.items) < len(parsed_items):
                form.items.append_entry()
            for idx, parsed_item in enumerate(parsed_items):
                if idx >= len(form.items):
                    break
                form.items[idx].item.data = parsed_item.get("item_id")
                form.items[idx].unit.data = parsed_item.get("unit_id")
                form.items[idx].quantity.data = parsed_item.get("quantity")
                form.items[idx].position.data = idx

    if request.method == "GET" and form.order_date.data is None:
        form.order_date.data = datetime.date.today()
    if request.method == "GET" and form.expected_date.data is None:
        form.expected_date.data = datetime.date.today() + datetime.timedelta(days=1)
    if form.validate_on_submit():
        vendor_record = db.session.get(Vendor, form.vendor.data)
        vendor_name = (
            f"{vendor_record.first_name} {vendor_record.last_name}"
            if vendor_record
            else ""
        )
        expected_total = (
            float(form.expected_total_cost.data)
            if form.expected_total_cost.data is not None
            else None
        )
        po = PurchaseOrder(
            vendor_id=form.vendor.data,
            user_id=current_user.id,
            vendor_name=vendor_name,
            order_number=form.order_number.data or None,
            order_date=form.order_date.data,
            expected_date=form.expected_date.data,
            expected_total_cost=expected_total,
            delivery_charge=form.delivery_charge.data or 0.0,
        )
        db.session.add(po)
        db.session.commit()

        item_entries = []
        fallback_counter = 0
        items = [
            key
            for key in request.form.keys()
            if key.startswith("items-") and key.endswith("-item")
        ]
        for field in items:
            index = field.split("-")[1]
            item_id = request.form.get(f"items-{index}-item", type=int)
            unit_id = request.form.get(f"items-{index}-unit", type=int)
            quantity = coerce_float(request.form.get(f"items-{index}-quantity"))
            position = request.form.get(f"items-{index}-position", type=int)
            if item_id and quantity is not None:
                item_entries.append(
                    {
                        "item_id": item_id,
                        "unit_id": unit_id,
                        "quantity": quantity,
                        "position": position,
                        "fallback": fallback_counter,
                    }
                )
                fallback_counter += 1

        item_entries.sort(
            key=lambda entry: (
                entry["position"]
                if entry["position"] is not None
                else entry["fallback"],
                entry["fallback"],
            )
        )

        for order_index, entry in enumerate(item_entries):
            db.session.add(
                PurchaseOrderItem(
                    purchase_order_id=po.id,
                    item_id=entry["item_id"],
                    unit_id=entry["unit_id"],
                    quantity=entry["quantity"],
                    unit_cost=None,
                    position=order_index,
                )
            )

        db.session.commit()
        _clear_purchase_upload_state()
        log_activity(f"Created purchase order {po.id}")
        flash("Purchase order created successfully!", "success")
        return redirect(url_for("purchase.view_purchase_orders"))

    selected_item_ids = []
    for item_form in form.items:
        if item_form.item.data:
            try:
                selected_item_ids.append(int(item_form.item.data))
            except (TypeError, ValueError):
                continue
    item_lookup = {}
    if selected_item_ids:
        item_lookup = {
            item.id: {
                "name": item.name,
                "gl_code": item.purchase_gl_code.code
                if item.purchase_gl_code
                else "",
            }
            for item in Item.query.options(selectinload(Item.purchase_gl_code))
            .filter(Item.id.in_(selected_item_ids))
            .all()
        }

    codes = _purchase_gl_code_choices()
    return render_template(
        "purchase_orders/create_purchase_order.html",
        form=form,
        gl_codes=codes,
        item_lookup=item_lookup,
        upload_state=upload_state,
    )


@purchase.route(
    "/purchase_orders/recommendations", methods=["GET", "POST"]
)
@login_required
def purchase_order_recommendations():
    """Display demand-based purchase order recommendations."""

    params = request.values if request.method == "POST" else request.args
    raw_lookback = coerce_float(params.get("lookback_days"))
    lookback_days = int(raw_lookback) if raw_lookback is not None else 0
    if not lookback_days:
        lookback_days = 30
    location_id = params.get("location_id", type=int)
    item_id = params.get("item_id", type=int)
    attendance_multiplier = coerce_float(params.get("attendance_multiplier")) or 1.0
    weather_multiplier = coerce_float(params.get("weather_multiplier")) or 1.0
    promo_multiplier = coerce_float(params.get("promo_multiplier")) or 1.0
    raw_lead_time = coerce_float(params.get("lead_time_days"))
    lead_time_days = int(raw_lead_time) if raw_lead_time is not None else 0
    if not lead_time_days:
        lead_time_days = 3

    helper = DemandForecastingHelper(
        lookback_days=lookback_days, lead_time_days=lead_time_days
    )
    recommendations = helper.build_recommendations(
        location_ids=[location_id] if location_id else None,
        item_ids=[item_id] if item_id else None,
        attendance_multiplier=attendance_multiplier,
        weather_multiplier=weather_multiplier,
        promo_multiplier=promo_multiplier,
    )

    vendors = Vendor.query.filter_by(archived=False).all()
    locations = Location.query.filter_by(archived=False).all()

    wants_json = (
        request.args.get("format") == "json"
        or request.accept_mimetypes["application/json"]
        > request.accept_mimetypes["text/html"]
    )

    if wants_json:
        payload = {
            "meta": {
                "lookback_days": lookback_days,
                "attendance_multiplier": attendance_multiplier,
                "weather_multiplier": weather_multiplier,
                "promo_multiplier": promo_multiplier,
                "lead_time_days": lead_time_days,
            },
            "data": [
                {
                    "item_id": rec.item.id,
                    "item_name": rec.item.name,
                    "location_id": rec.location.id,
                    "location_name": rec.location.name,
                    "history": {
                        key: round(value, 6)
                        for key, value in rec.history.items()
                        if key != "last_activity_ts"
                    },
                    "base_consumption": round(rec.base_consumption, 6),
                    "adjusted_demand": round(rec.adjusted_demand, 6),
                    "recommended_quantity": round(rec.recommended_quantity, 6),
                    "suggested_delivery_date": rec.suggested_delivery_date.isoformat(),
                    "default_unit_id": rec.default_unit_id,
                }
                for rec in recommendations
            ],
        }
        return jsonify(payload)

    chart_rows = [
        {
            "label": f"{rec.item.name} @ {rec.location.name}",
            "recommended": rec.recommended_quantity,
            "consumption": rec.base_consumption,
            "incoming": rec.history["transfer_in_qty"]
            + rec.history["invoice_qty"]
            + rec.history["open_po_qty"],
        }
        for rec in recommendations
    ]

    if request.method == "POST" and request.form.get("action") == "seed":
        selected_keys = request.form.getlist("selected_lines")
        if not selected_keys:
            flash("No recommendation lines were selected.", "warning")
        else:
            seed_items = []
            override_map = {
                key: coerce_float(request.form.get(f"override-{key}"))
                for key in selected_keys
            }
            rec_map = {
                f"{rec.item.id}:{rec.location.id}": rec for rec in recommendations
            }
            for key in selected_keys:
                rec = rec_map.get(key)
                if not rec:
                    continue
                quantity = override_map.get(key)
                if quantity is None or quantity <= 0:
                    quantity = rec.recommended_quantity
                if quantity <= 0:
                    continue
                seed_items.append(
                    {
                        "item_id": rec.item.id,
                        "unit_id": rec.default_unit_id,
                        "quantity": float(quantity),
                    }
                )

            vendor_id = request.form.get("seed_vendor_id", type=int)
            expected_date = request.form.get("seed_expected_date")
            order_date = request.form.get("seed_order_date") or datetime.date.today().isoformat()

            if seed_items and vendor_id:
                session["po_recommendation_seed"] = {
                    "vendor_id": vendor_id,
                    "expected_date": expected_date
                    or (recommendations[0].suggested_delivery_date.isoformat()
                        if recommendations
                        else datetime.date.today().isoformat()),
                    "order_date": order_date,
                    "items": seed_items,
                }
                session.modified = True
                flash("Purchase order draft populated from recommendations.", "success")
                return redirect(url_for("purchase.create_purchase_order"))
            if not vendor_id:
                flash("Select a vendor before creating a draft purchase order.", "warning")
            if not seed_items:
                flash("No recommendation lines were eligible to push to a draft.", "warning")

    today = datetime.date.today()

    return render_template(
        "purchase_orders/recommendations.html",
        recommendations=recommendations,
        vendors=vendors,
        locations=locations,
        selected_vendor=params.get("seed_vendor_id", type=int),
        selected_location=location_id,
        selected_item=item_id,
        lookback_days=lookback_days,
        attendance_multiplier=attendance_multiplier,
        weather_multiplier=weather_multiplier,
        promo_multiplier=promo_multiplier,
        lead_time_days=lead_time_days,
        chart_rows=chart_rows,
        today=today,
    )


@purchase.route("/purchase_orders/edit/<int:po_id>", methods=["GET", "POST"])
@login_required
def edit_purchase_order(po_id):
    """Modify a pending purchase order."""
    po = db.session.get(PurchaseOrder, po_id)
    if po is None:
        abort(404)
    form = PurchaseOrderForm()
    if form.validate_on_submit():
        existing_unit_costs = {}
        for poi in po.items:
            key = (poi.item_id, poi.unit_id)
            existing_unit_costs.setdefault(key, []).append(poi.unit_cost)

        po.vendor_id = form.vendor.data
        vendor_record = db.session.get(Vendor, form.vendor.data)
        po.vendor_name = (
            f"{vendor_record.first_name} {vendor_record.last_name}"
            if vendor_record
            else ""
        )
        po.order_number = form.order_number.data or None
        po.order_date = form.order_date.data
        po.expected_date = form.expected_date.data
        po.expected_total_cost = (
            float(form.expected_total_cost.data)
            if form.expected_total_cost.data is not None
            else None
        )
        po.delivery_charge = form.delivery_charge.data or 0.0

        PurchaseOrderItem.query.filter_by(purchase_order_id=po.id).delete()

        item_entries = []
        fallback_counter = 0
        items = [
            key
            for key in request.form.keys()
            if key.startswith("items-") and key.endswith("-item")
        ]
        for field in items:
            index = field.split("-")[1]
            item_id = request.form.get(f"items-{index}-item", type=int)
            unit_id = request.form.get(f"items-{index}-unit", type=int)
            quantity = coerce_float(request.form.get(f"items-{index}-quantity"))
            position = request.form.get(f"items-{index}-position", type=int)
            unit_cost = None
            key = (item_id, unit_id)
            if key in existing_unit_costs and existing_unit_costs[key]:
                unit_cost = existing_unit_costs[key].pop(0)
            if item_id and quantity is not None:
                item_entries.append(
                    {
                        "item_id": item_id,
                        "unit_id": unit_id,
                        "quantity": quantity,
                        "unit_cost": unit_cost,
                        "position": position,
                        "fallback": fallback_counter,
                    }
                )
                fallback_counter += 1

        item_entries.sort(
            key=lambda entry: (
                entry["position"]
                if entry["position"] is not None
                else entry["fallback"],
                entry["fallback"],
            )
        )

        for order_index, entry in enumerate(item_entries):
            db.session.add(
                PurchaseOrderItem(
                    purchase_order_id=po.id,
                    item_id=entry["item_id"],
                    unit_id=entry["unit_id"],
                    quantity=entry["quantity"],
                    unit_cost=entry.get("unit_cost"),
                    position=order_index,
                )
            )

        db.session.commit()
        log_activity(f"Edited purchase order {po.id}")
        flash("Purchase order updated successfully!", "success")
        return redirect(url_for("purchase.view_purchase_orders"))

    if request.method == "GET":
        form.vendor.data = po.vendor_id
        form.order_number.data = po.order_number
        form.order_date.data = po.order_date
        form.expected_date.data = po.expected_date
        if po.expected_total_cost is not None:
            form.expected_total_cost.data = po.expected_total_cost
        form.delivery_charge.data = po.delivery_charge
        form.items.min_entries = max(1, len(po.items))
        for i, poi in enumerate(po.items):
            if len(form.items) <= i:
                form.items.append_entry()
        for i, poi in enumerate(po.items):
            form.items[i].item.data = poi.item_id
            form.items[i].unit.data = poi.unit_id
            form.items[i].quantity.data = poi.quantity
            form.items[i].position.data = poi.position

    selected_item_ids = []
    for item_form in form.items:
        if item_form.item.data:
            try:
                selected_item_ids.append(int(item_form.item.data))
            except (TypeError, ValueError):
                continue
    item_lookup = {}
    if selected_item_ids:
        item_lookup = {
            item.id: {
                "name": item.name,
                "gl_code": item.purchase_gl_code.code
                if item.purchase_gl_code
                else "",
            }
            for item in Item.query.options(selectinload(Item.purchase_gl_code))
            .filter(Item.id.in_(selected_item_ids))
            .all()
        }

    codes = _purchase_gl_code_choices()
    return render_template(
        "purchase_orders/edit_purchase_order.html",
        form=form,
        po=po,
        gl_codes=codes,
        item_lookup=item_lookup,
    )


@purchase.route("/purchase_orders/<int:po_id>/delete", methods=["POST"])
@login_required
def delete_purchase_order(po_id):
    """Delete an unreceived purchase order."""
    form = DeleteForm()
    if not form.validate_on_submit():
        abort(400)
    po = db.session.get(PurchaseOrder, po_id)
    if po is None:
        abort(404)
    if po.received:
        flash(
            "Cannot delete a purchase order that has been received.", "error"
        )
        return redirect(url_for("purchase.view_purchase_orders"))
    db.session.delete(po)
    db.session.commit()
    log_activity(f"Deleted purchase order {po.id}")
    flash("Purchase order deleted successfully!", "success")
    return redirect(url_for("purchase.view_purchase_orders"))


@purchase.route(
    "/purchase_orders/<int:po_id>/receive", methods=["GET", "POST"]
)
@login_required
def receive_invoice(po_id):
    """Receive a purchase order and create an invoice."""
    po = db.session.get(PurchaseOrder, po_id)
    if po is None:
        abort(404)
    form = ReceiveInvoiceForm()
    gl_code_choices = load_purchase_gl_code_choices()
    department_defaults = Setting.get_receive_location_defaults()
    draft = PurchaseInvoiceDraft.query.filter_by(purchase_order_id=po.id).first()
    draft_data = draft.data if draft else None
    if request.method == "GET":
        prefill_items = []
        if draft_data:
            prefill_items = draft_data.get("items", []) or []
        if not prefill_items:
            prefill_items = [
                {
                    "item_id": poi.item_id,
                    "unit_id": poi.unit_id,
                    "quantity": poi.quantity,
                    "position": poi.position,
                    "gl_code_id": None,
                    "cost": poi.unit_cost,
                    "location_id": None,
                }
                for poi in po.items
            ]

        form.items.min_entries = max(1, len(prefill_items))
        while len(form.items) < len(prefill_items):
            form.items.append_entry()

        if draft_data:
            form.invoice_number.data = draft_data.get("invoice_number")
            if draft_data.get("received_date"):
                try:
                    form.received_date.data = datetime.date.fromisoformat(
                        draft_data["received_date"]
                    )
                except ValueError:
                    pass
            if draft_data.get("department"):
                form.department.data = draft_data.get("department")
            if draft_data.get("gst") is not None:
                form.gst.data = draft_data.get("gst")
            if draft_data.get("pst") is not None:
                form.pst.data = draft_data.get("pst")
            if draft_data.get("delivery_charge") is not None:
                form.delivery_charge.data = draft_data.get("delivery_charge")
            invoice_location_id = draft_data.get("location_id")
            if invoice_location_id and any(
                choice_id == invoice_location_id
                for choice_id, _ in form.location_id.choices
            ):
                form.location_id.data = invoice_location_id
        else:
            form.delivery_charge.data = po.delivery_charge
            if not form.received_date.data:
                form.received_date.data = datetime.date.today()

        selected_department = form.department.data or ""
        if not form.location_id.data:
            default_location_id = department_defaults.get(selected_department)
            if default_location_id and any(
                choice_id == default_location_id
                for choice_id, _ in form.location_id.choices
            ):
                form.location_id.data = default_location_id

        location_choices = [(0, "Use Invoice Location")] + [
            (value, label) for value, label in form.location_id.choices
        ]
        for item_form in form.items:
            item_form.item.choices = [
                (i.id, i.name)
                for i in Item.query.filter_by(archived=False).all()
            ]
            item_form.unit.choices = [
                (u.id, u.name) for u in ItemUnit.query.all()
            ]
            item_form.location_id.choices = location_choices
            if item_form.location_id.data is None:
                item_form.location_id.data = 0
            item_form.gl_code.choices = [
                (value, label) for value, label in gl_code_choices
            ]
        for index, item_data in enumerate(prefill_items):
            if index >= len(form.items):
                break
            form.items[index].item.data = item_data.get("item_id")
            form.items[index].unit.data = item_data.get("unit_id")
            if item_data.get("quantity") is not None:
                form.items[index].quantity.data = item_data.get("quantity")
            if item_data.get("cost") is not None:
                form.items[index].cost.data = item_data.get("cost")
            if item_data.get("container_deposit") is not None:
                form.items[index].container_deposit.data = item_data.get(
                    "container_deposit"
                )
            form.items[index].position.data = item_data.get("position")
            gl_code_value = item_data.get("gl_code_id")
            form.items[index].gl_code.data = gl_code_value or 0
            location_value = item_data.get("location_id")
            form.items[index].location_id.data = location_value or 0
    if form.validate_on_submit():
        location_obj = db.session.get(Location, form.location_id.data)
        if not PurchaseOrderItemArchive.query.filter_by(
            purchase_order_id=po.id
        ).first():
            for poi in po.items:
                db.session.add(
                    PurchaseOrderItemArchive(
                        purchase_order_id=po.id,
                        position=poi.position,
                        item_id=poi.item_id,
                        unit_id=poi.unit_id,
                        quantity=poi.quantity,
                        unit_cost=poi.unit_cost,
                    )
                )
            db.session.commit()
        invoice = PurchaseInvoice(
            purchase_order_id=po.id,
            user_id=current_user.id,
            location_id=form.location_id.data,
            vendor_name=po.vendor_name,
            location_name=location_obj.name if location_obj else "",
            received_date=form.received_date.data,
            invoice_number=form.invoice_number.data,
            department=form.department.data or None,
            gst=form.gst.data or 0.0,
            pst=form.pst.data or 0.0,
            delivery_charge=form.delivery_charge.data or 0.0,
        )
        db.session.add(invoice)
        # Flush so the invoice has an ID for related line items without
        # committing the transaction yet. This keeps all updates in a single
        # commit so item cost changes persist reliably.
        db.session.flush()

        item_entries = []
        fallback_counter = 0
        items = [
            key
            for key in request.form.keys()
            if key.startswith("items-") and key.endswith("-item")
        ]
        for field in items:
            index = field.split("-")[1]
            item_id = request.form.get(f"items-{index}-item", type=int)
            unit_id = request.form.get(f"items-{index}-unit", type=int)
            quantity = coerce_float(request.form.get(f"items-{index}-quantity"))
            cost = coerce_float(request.form.get(f"items-{index}-cost"))
            container_deposit_raw = coerce_float(
                request.form.get(f"items-{index}-container_deposit")
            )
            position = request.form.get(f"items-{index}-position", type=int)
            gl_code_id = request.form.get(f"items-{index}-gl_code", type=int)
            gl_code_id = gl_code_id or None
            line_location_id = request.form.get(
                f"items-{index}-location_id", type=int
            )
            line_location_id = line_location_id or None
            if item_id and quantity is not None and cost is not None:
                container_deposit = (
                    abs(container_deposit_raw) if container_deposit_raw is not None else 0.0
                )
                item_entries.append(
                    {
                        "item_id": item_id,
                        "unit_id": unit_id,
                        "quantity": quantity,
                        "cost": abs(cost),
                        "container_deposit": container_deposit,
                        "deposit_provided": container_deposit_raw is not None,
                        "position": position,
                        "fallback": fallback_counter,
                        "gl_code_id": gl_code_id,
                        "location_id": line_location_id,
                    }
                )
                fallback_counter += 1

        item_entries.sort(
            key=lambda entry: (
                entry["position"]
                if entry["position"] is not None
                else entry["fallback"],
                entry["fallback"],
            )
        )

        for order_index, entry in enumerate(item_entries):
            item_obj = db.session.get(Item, entry["item_id"])
            unit_obj = (
                db.session.get(ItemUnit, entry["unit_id"]) if entry["unit_id"] else None
            )

            prev_cost = item_obj.cost if item_obj and item_obj.cost else 0.0
            quantity = entry["quantity"]
            cost = entry["cost"]
            container_deposit = entry.get("container_deposit", 0.0)

            db.session.add(
                PurchaseInvoiceItem(
                    invoice_id=invoice.id,
                    item_id=item_obj.id if item_obj else None,
                    unit_id=unit_obj.id if unit_obj else None,
                    item_name=item_obj.name if item_obj else "",
                    unit_name=unit_obj.name if unit_obj else None,
                    quantity=quantity,
                    cost=cost,
                    container_deposit=container_deposit,
                    prev_cost=prev_cost,
                    position=order_index,
                    purchase_gl_code_id=entry["gl_code_id"],
                    location_id=entry["location_id"],
                )
            )

            if item_obj:
                factor = unit_obj.factor if unit_obj and unit_obj.factor else 1
                prev_qty = (
                    db.session.query(
                        db.func.sum(LocationStandItem.expected_count)
                    )
                    .filter(LocationStandItem.item_id == item_obj.id)
                    .scalar()
                    or 0
                )
                new_qty = quantity * factor
                total_qty = prev_qty + new_qty

                # Cost per base unit for the newly received stock
                cost_per_unit = cost / factor if factor else cost
                prev_total_cost = prev_qty * prev_cost
                new_total_cost = cost_per_unit * new_qty
                if total_qty > 0:
                    weighted_cost = (prev_total_cost + new_total_cost) / total_qty
                else:
                    weighted_cost = cost_per_unit

                item_obj.quantity = total_qty
                item_obj.cost = weighted_cost

                # Explicitly mark the item as dirty so cost updates persist
                db.session.add(item_obj)

                line_location_id = entry["location_id"] or invoice.location_id
                record = LocationStandItem.query.filter_by(
                    location_id=line_location_id, item_id=item_obj.id
                ).first()
                if not record:
                    record = LocationStandItem(
                        location_id=line_location_id,
                        item_id=item_obj.id,
                        expected_count=0,
                        purchase_gl_code_id=item_obj.purchase_gl_code_id,
                    )
                    db.session.add(record)
                elif (
                    record.purchase_gl_code_id is None
                    and item_obj.purchase_gl_code_id is not None
                ):
                    record.purchase_gl_code_id = item_obj.purchase_gl_code_id
                record.expected_count += quantity * factor

                if entry.get("deposit_provided"):
                    base_deposit = (
                        container_deposit / factor if factor else container_deposit
                    )
                    item_obj.container_deposit = base_deposit
                    db.session.add(item_obj)

                # Ensure the in-memory changes are sent to the database so
                # subsequent iterations or queries within this request see
                # the updated cost and quantity values immediately.
                db.session.flush()
        po.received = True
        db.session.add(po)
        if draft:
            db.session.delete(draft)
        # Commit once so that invoice, items, and updated item costs are saved
        # atomically, ensuring the weighted cost persists in the database.
        db.session.commit()
        log_activity(f"Received invoice {invoice.id} for PO {po.id}")
        flash("Invoice received successfully!", "success")
        return redirect(url_for("purchase.view_purchase_invoices"))

    return render_template(
        "purchase_orders/receive_invoice.html",
        form=form,
        po=po,
        gl_code_choices=gl_code_choices,
        department_defaults=department_defaults,
    )


@purchase.route("/purchase_invoices", methods=["GET"])
@login_required
def view_purchase_invoices():
    """List all received purchase invoices."""
    page = request.args.get("page", 1, type=int)
    per_page = get_per_page()
    invoice_number = request.args.get("invoice_number")
    if invoice_number is not None:
        invoice_number = invoice_number.strip()
    if not invoice_number:
        invoice_number = None
    po_number = request.args.get("po_number", type=int)
    vendor_id = request.args.get("vendor_id", type=int)
    location_id = request.args.get("location_id", type=int)
    start_date_str = request.args.get("start_date")
    end_date_str = request.args.get("end_date")
    amount_filter_raw = request.args.get("amount_filter")
    amount_value_raw = request.args.get("amount_value")

    allowed_amount_filters = {"gt", "lt", "eq"}
    amount_filter = (
        amount_filter_raw if amount_filter_raw in allowed_amount_filters else None
    )
    amount_value = (
        coerce_float(amount_value_raw, default=None)
        if amount_value_raw not in (None, "")
        else None
    )

    start_date = None
    end_date = None
    if start_date_str:
        try:
            start_date = datetime.date.fromisoformat(start_date_str)
        except ValueError:
            flash("Invalid start date.", "error")
            return redirect(url_for("purchase.view_purchase_invoices"))
    if end_date_str:
        try:
            end_date = datetime.date.fromisoformat(end_date_str)
        except ValueError:
            flash("Invalid end date.", "error")
            return redirect(url_for("purchase.view_purchase_invoices"))
    if start_date and end_date and start_date > end_date:
        flash("Invalid date range: start cannot be after end.", "error")
        return redirect(url_for("purchase.view_purchase_invoices"))

    raw_item_ids = request.args.getlist("item_id")
    selected_item_ids = []
    seen_item_ids = set()
    for raw_item_id in raw_item_ids:
        try:
            parsed_id = int(raw_item_id)
        except (TypeError, ValueError):
            continue
        if parsed_id in seen_item_ids:
            continue
        seen_item_ids.add(parsed_id)
        selected_item_ids.append(parsed_id)

    items = Item.query.order_by(Item.name).all()
    item_lookup = {item.id: item for item in items}
    selected_items = [
        item_lookup[item_id]
        for item_id in selected_item_ids
        if item_id in item_lookup
    ]
    selected_item_ids = [item.id for item in selected_items]
    selected_item_names = [item.name for item in selected_items]

    query = PurchaseInvoice.query.options(
        selectinload(PurchaseInvoice.purchase_order).selectinload(PurchaseOrder.vendor),
        selectinload(PurchaseInvoice.items)
        .selectinload(PurchaseInvoiceItem.item),
        selectinload(PurchaseInvoice.items)
        .selectinload(PurchaseInvoiceItem.unit),
        selectinload(PurchaseInvoice.items)
        .selectinload(PurchaseInvoiceItem.location),
        selectinload(PurchaseInvoice.items)
        .selectinload(PurchaseInvoiceItem.purchase_gl_code),
    )
    if invoice_number:
        query = query.filter(
            PurchaseInvoice.invoice_number.ilike(f"%{invoice_number}%")
        )
    if po_number:
        query = query.filter(PurchaseInvoice.purchase_order_id == po_number)
    if vendor_id:
        query = query.join(PurchaseOrder).filter(PurchaseOrder.vendor_id == vendor_id)
    if location_id:
        query = query.filter(PurchaseInvoice.location_id == location_id)
    if start_date:
        query = query.filter(PurchaseInvoice.received_date >= start_date)
    if end_date:
        query = query.filter(PurchaseInvoice.received_date <= end_date)
    if selected_item_ids:
        query = query.filter(
            PurchaseInvoice.items.any(
                PurchaseInvoiceItem.item_id.in_(selected_item_ids)
            )
        )

    if amount_filter and amount_value is not None:
        item_totals_subq = (
            db.session.query(
                PurchaseInvoiceItem.invoice_id.label("invoice_id"),
                func.sum(
                    PurchaseInvoiceItem.quantity
                    * (
                        PurchaseInvoiceItem.cost
                        + PurchaseInvoiceItem.container_deposit
                    )
                ).label("item_sum"),
            )
            .group_by(PurchaseInvoiceItem.invoice_id)
            .subquery()
        )

        query = query.outerjoin(
            item_totals_subq, item_totals_subq.c.invoice_id == PurchaseInvoice.id
        )

        total_expression = (
            func.coalesce(item_totals_subq.c.item_sum, 0)
            + func.coalesce(PurchaseInvoice.delivery_charge, 0)
            + func.coalesce(PurchaseInvoice.gst, 0)
            + func.coalesce(PurchaseInvoice.pst, 0)
        )

        if amount_filter == "gt":
            query = query.filter(total_expression > amount_value)
        elif amount_filter == "lt":
            query = query.filter(total_expression < amount_value)
        elif amount_filter == "eq":
            query = query.filter(total_expression == amount_value)

    invoices = query.order_by(
        PurchaseInvoice.received_date.desc(), PurchaseInvoice.id.desc()
    ).paginate(page=page, per_page=per_page)

    vendors = Vendor.query.order_by(Vendor.first_name, Vendor.last_name).all()
    locations = Location.query.order_by(Location.name).all()
    active_vendor = db.session.get(Vendor, vendor_id) if vendor_id else None
    active_location = db.session.get(Location, location_id) if location_id else None

    return render_template(
        "purchase_invoices/view_purchase_invoices.html",
        invoices=invoices,
        vendors=vendors,
        locations=locations,
        invoice_number=invoice_number,
        po_number=po_number,
        vendor_id=vendor_id,
        location_id=location_id,
        start_date=start_date_str,
        end_date=end_date_str,
        active_vendor=active_vendor,
        active_location=active_location,
        items=items,
        selected_items=selected_items,
        selected_item_ids=selected_item_ids,
        selected_item_names=selected_item_names,
        amount_filter=amount_filter,
        amount_value=amount_value,
        per_page=per_page,
        pagination_args=build_pagination_args(per_page),
    )


@purchase.route("/purchase_invoices/<int:invoice_id>")
@login_required
def view_purchase_invoice(invoice_id):
    """Display a purchase invoice."""
    invoice = (
        PurchaseInvoice.query.options(
            selectinload(PurchaseInvoice.items)
            .selectinload(PurchaseInvoiceItem.item),
            selectinload(PurchaseInvoice.items)
            .selectinload(PurchaseInvoiceItem.unit),
            selectinload(PurchaseInvoice.items)
            .selectinload(PurchaseInvoiceItem.location),
            selectinload(PurchaseInvoice.items)
            .selectinload(PurchaseInvoiceItem.purchase_gl_code),
            selectinload(PurchaseInvoice.purchase_order).selectinload(
                PurchaseOrder.vendor
            ),
            selectinload(PurchaseInvoice.location),
        ).get(invoice_id)
    )
    if invoice is None:
        abort(404)
    log_activity(
        f"Opened purchase invoice {invoice.id} for posting/payment review"
    )
    return render_template(
        "purchase_invoices/view_purchase_invoice.html", invoice=invoice
    )


@purchase.route("/purchase_invoices/<int:invoice_id>/report")
@login_required
def legacy_purchase_invoice_report(invoice_id: int):
    """Backwards compatible endpoint for purchase invoice GL reports."""

    invoice = (
        PurchaseInvoice.query.options(
            selectinload(PurchaseInvoice.items)
            .selectinload(PurchaseInvoiceItem.item),
            selectinload(PurchaseInvoice.items)
            .selectinload(PurchaseInvoiceItem.purchase_gl_code),
            selectinload(PurchaseInvoice.purchase_order).selectinload(
                PurchaseOrder.vendor
            ),
            selectinload(PurchaseInvoice.location),
        )
        .filter_by(id=invoice_id)
        .first()
    )

    if invoice is None:
        abort(404)

    rows, totals = _invoice_gl_code_rows(invoice)
    report_data = {row["code"]: row for row in rows}

    return render_template(
        "report_invoice_gl_code.html",
        invoice=invoice,
        rows=rows,
        totals=totals,
        report=report_data,
    )


@purchase.route(
    "/purchase_invoices/<int:invoice_id>/reverse", methods=["GET", "POST"]
)
@login_required
def reverse_purchase_invoice(invoice_id):
    """Undo receipt of a purchase invoice."""
    invoice = db.session.get(PurchaseInvoice, invoice_id)
    if invoice is None:
        abort(404)
    po = db.session.get(PurchaseOrder, invoice.purchase_order_id)
    if po is None:
        abort(404)
    warnings = check_negative_invoice_reverse(invoice)
    form = ConfirmForm()
    if warnings and request.method == "GET":
        return render_template(
            "confirm_action.html",
            form=form,
            warnings=warnings,
            action_url=url_for(
                "purchase.reverse_purchase_invoice", invoice_id=invoice_id
            ),
            cancel_url=url_for("purchase.view_purchase_invoices"),
            title="Confirm Invoice Reversal",
        )
    if warnings and not form.validate_on_submit():
        return render_template(
            "confirm_action.html",
            form=form,
            warnings=warnings,
            action_url=url_for(
                "purchase.reverse_purchase_invoice", invoice_id=invoice_id
            ),
            cancel_url=url_for("purchase.view_purchase_invoices"),
            title="Confirm Invoice Reversal",
        )
    draft_payload = {
        "invoice_number": invoice.invoice_number,
        "received_date": invoice.received_date.isoformat()
        if invoice.received_date
        else None,
        "location_id": invoice.location_id,
        "department": invoice.department,
        "gst": invoice.gst,
        "pst": invoice.pst,
        "delivery_charge": invoice.delivery_charge,
        "items": [
            {
                "item_id": inv_item.item_id,
                "unit_id": inv_item.unit_id,
                "quantity": inv_item.quantity,
                "cost": inv_item.cost,
                "container_deposit": inv_item.container_deposit,
                "position": inv_item.position,
                "gl_code_id": inv_item.purchase_gl_code_id,
                "location_id": inv_item.location_id,
            }
            for inv_item in invoice.items
        ],
    }
    existing_draft = PurchaseInvoiceDraft.query.filter_by(
        purchase_order_id=po.id
    ).first()
    if existing_draft:
        existing_draft.update_payload(draft_payload)
    else:
        db.session.add(
            PurchaseInvoiceDraft(
                purchase_order_id=po.id,
                payload=json.dumps(draft_payload),
            )
        )
    for inv_item in invoice.items:
        factor = 1
        if inv_item.unit_id:
            unit = db.session.get(ItemUnit, inv_item.unit_id)
            if unit:
                factor = unit.factor
        itm = db.session.get(Item, inv_item.item_id)
        if not itm:
            flash(
                f"Cannot reverse invoice because item '{inv_item.item_name}' no longer exists.",
                "error",
            )
            return redirect(url_for("purchase.view_purchase_invoices"))

        removed_qty = inv_item.quantity * factor
        qty_before = itm.quantity
        itm.quantity = qty_before - removed_qty
        itm.cost = inv_item.prev_cost or 0.0

        # Update expected count for the location where items were received
        line_location_id = inv_item.location_id or invoice.location_id
        record = LocationStandItem.query.filter_by(
            location_id=line_location_id,
            item_id=itm.id,
        ).first()
        if not record:
            record = LocationStandItem(
                location_id=line_location_id,
                item_id=itm.id,
                expected_count=0,
                purchase_gl_code_id=itm.purchase_gl_code_id,
            )
            db.session.add(record)
        elif (
            record.purchase_gl_code_id is None
            and itm.purchase_gl_code_id is not None
        ):
            record.purchase_gl_code_id = itm.purchase_gl_code_id
        new_count = record.expected_count - removed_qty
        record.expected_count = new_count

    location_ids = {
        inv_item.location_id or invoice.location_id for inv_item in invoice.items
    }
    missing_locations = [
        loc_id
        for loc_id in location_ids
        if loc_id and not db.session.get(Location, loc_id)
    ]
    if missing_locations:
        flash(
            "Cannot reverse invoice because one or more receiving locations no longer exist.",
            "error",
        )
        return redirect(url_for("purchase.view_purchase_invoices"))

    PurchaseInvoiceItem.query.filter_by(invoice_id=invoice.id).delete()
    db.session.delete(invoice)
    po.received = False
    db.session.commit()
    flash("Invoice reversed successfully", "success")
    return redirect(url_for("purchase.view_purchase_orders"))
