                    # Explicitly mark the item as dirty so cost updates persist
                    db.session.add(item_obj)

                    record = LocationStandItem.query.filter_by(
                        location_id=invoice.location_id, item_id=item_obj.id
                    ).first()
                    if not record:
                        record = LocationStandItem(
                            location_id=invoice.location_id,
                            item_id=item_obj.id,
                            expected_count=0,
                            purchase_gl_code_id=item_obj.purchase_gl_code_id,
                        )
                        db.session.add(record)
                    elif (
                        record.purchase_gl_code_id is None
                        and item_obj.purchase_gl_code_id is not None
                    ):
                        record.purchase_gl_code_id = (
                            item_obj.purchase_gl_code_id
                        )
                    record.expected_count += quantity * factor

                    # Ensure the in-memory changes are sent to the database so
                    # subsequent iterations or queries within this request see
                    # the updated cost and quantity values immediately.
                    db.session.flush()
        db.session.commit()
        po.received = True
        db.session.add(po)
        db.session.commit()
        log_activity(f"Received invoice {invoice.id} for PO {po.id}")
        flash("Invoice received successfully!", "success")
        return redirect(url_for("purchase.view_purchase_invoices"))

    return render_template(
        "purchase_orders/receive_invoice.html", form=form, po=po
    )


@purchase.route("/purchase_invoices", methods=["GET"])
@login_required
def view_purchase_invoices():
    """List all received purchase invoices."""
    page = request.args.get("page", 1, type=int)
    invoice_id = request.args.get("invoice_id", type=int)
    po_number = request.args.get("po_number", type=int)
    vendor_id = request.args.get("vendor_id", type=int)
    location_id = request.args.get("location_id", type=int)
    start_date_str = request.args.get("start_date")
    end_date_str = request.args.get("end_date")

    start_date = None
    end_date = None
    if start_date_str:
        try:
            start_date = datetime.date.fromisoformat(start_date_str)
        except ValueError:
            flash("Invalid start date.", "error")
            return redirect(url_for("purchase.view_purchase_invoices"))
    if end_date_str:
        try:
            end_date = datetime.date.fromisoformat(end_date_str)
        except ValueError:
            flash("Invalid end date.", "error")
            return redirect(url_for("purchase.view_purchase_invoices"))
    if start_date and end_date and start_date > end_date:
        flash("Invalid date range: start cannot be after end.", "error")
        return redirect(url_for("purchase.view_purchase_invoices"))

    query = PurchaseInvoice.query
    if invoice_id:
        query = query.filter(PurchaseInvoice.id == invoice_id)
    if po_number:
        query = query.filter(PurchaseInvoice.purchase_order_id == po_number)
    if vendor_id:
        query = query.join(PurchaseOrder).filter(PurchaseOrder.vendor_id == vendor_id)
    if location_id:
        query = query.filter(PurchaseInvoice.location_id == location_id)
    if start_date:
        query = query.filter(PurchaseInvoice.received_date >= start_date)
    if end_date:
        query = query.filter(PurchaseInvoice.received_date <= end_date)

    invoices = query.order_by(
        PurchaseInvoice.received_date.desc(), PurchaseInvoice.id.desc()
    ).paginate(page=page, per_page=20)

    vendors = Vendor.query.order_by(Vendor.first_name, Vendor.last_name).all()
    locations = Location.query.order_by(Location.name).all()
    active_vendor = db.session.get(Vendor, vendor_id) if vendor_id else None
    active_location = db.session.get(Location, location_id) if location_id else None

    return render_template(
        "purchase_invoices/view_purchase_invoices.html",
        invoices=invoices,
        vendors=vendors,
        locations=locations,
        invoice_id=invoice_id,
        po_number=po_number,
        vendor_id=vendor_id,
        location_id=location_id,
        start_date=start_date_str,
        end_date=end_date_str,
        active_vendor=active_vendor,
        active_location=active_location,
    )


@purchase.route("/purchase_invoices/<int:invoice_id>")
@login_required
def view_purchase_invoice(invoice_id):
    """Display a purchase invoice."""
    invoice = db.session.get(PurchaseInvoice, invoice_id)
    if invoice is None:
        abort(404)
    return render_template(
        "purchase_invoices/view_purchase_invoice.html", invoice=invoice
    )


@purchase.route("/purchase_invoices/<int:invoice_id>/report")
@login_required
def purchase_invoice_report(invoice_id):
    """Generate a GL code summary for a purchase invoice."""
    invoice = db.session.get(PurchaseInvoice, invoice_id)
    if invoice is None:
        abort(404)

    gl_totals = {}
    item_total = 0
    for it in invoice.items:
        line_total = it.line_total
        item_total += line_total
        code = None
        if it.item:
            gl = it.item.purchase_gl_code_for_location(invoice.location_id)
            code = gl.code if gl else None
        if not code:
            code = "Unassigned"
        gl_totals[code] = gl_totals.get(code, 0) + line_total

    if item_total:
        for code, value in list(gl_totals.items()):
            share = value / item_total
            gl_totals[code] = (
                value + share * invoice.pst + share * invoice.delivery_charge
            )

    if invoice.gst:
        gl_totals["102702"] = gl_totals.get("102702", 0) + invoice.gst

    report = sorted(gl_totals.items())
    return render_template(
        "purchase_invoices/invoice_gl_report.html",
        invoice=invoice,
        report=report,
    )


@purchase.route(
    "/purchase_invoices/<int:invoice_id>/reverse", methods=["GET", "POST"]
)
@login_required
def reverse_purchase_invoice(invoice_id):
    """Undo receipt of a purchase invoice."""
    invoice = db.session.get(PurchaseInvoice, invoice_id)
    if invoice is None:
        abort(404)
    po = db.session.get(PurchaseOrder, invoice.purchase_order_id)
    if po is None:
        abort(404)
    warnings = check_negative_invoice_reverse(invoice)
    form = ConfirmForm()
    if warnings and request.method == "GET":
        return render_template(
            "confirm_action.html",
            form=form,
            warnings=warnings,
            action_url=url_for(
                "purchase.reverse_purchase_invoice", invoice_id=invoice_id
            ),
            cancel_url=url_for("purchase.view_purchase_invoices"),
            title="Confirm Invoice Reversal",
        )
    if warnings and not form.validate_on_submit():
        return render_template(
            "confirm_action.html",
            form=form,
            warnings=warnings,
            action_url=url_for(
                "purchase.reverse_purchase_invoice", invoice_id=invoice_id
            ),
            cancel_url=url_for("purchase.view_purchase_invoices"),
            title="Confirm Invoice Reversal",
        )
    for inv_item in invoice.items:
        factor = 1
        if inv_item.unit_id:
            unit = db.session.get(ItemUnit, inv_item.unit_id)
            if unit:
                factor = unit.factor
        itm = db.session.get(Item, inv_item.item_id)
        if not itm:
            flash(
                f"Cannot reverse invoice because item '{inv_item.item_name}' no longer exists.",
                "error",
            )
            return redirect(url_for("purchase.view_purchase_invoices"))

        removed_qty = inv_item.quantity * factor
        qty_before = itm.quantity
        itm.quantity = qty_before - removed_qty
        itm.cost = inv_item.prev_cost or 0.0

        # Update expected count for the location where items were received
        record = LocationStandItem.query.filter_by(
            location_id=invoice.location_id,
            item_id=itm.id,
        ).first()
        if not record:
            record = LocationStandItem(
                location_id=invoice.location_id,
                item_id=itm.id,
                expected_count=0,
                purchase_gl_code_id=itm.purchase_gl_code_id,
            )
            db.session.add(record)
        elif (
            record.purchase_gl_code_id is None
            and itm.purchase_gl_code_id is not None
        ):
            record.purchase_gl_code_id = itm.purchase_gl_code_id
        new_count = record.expected_count - removed_qty
        record.expected_count = new_count

    loc = db.session.get(Location, invoice.location_id)
    if not loc:
        flash(
            "Cannot reverse invoice because location no longer exists.",
            "error",
        )
        return redirect(url_for("purchase.view_purchase_invoices"))

    PurchaseInvoiceItem.query.filter_by(invoice_id=invoice.id).delete()
    db.session.delete(invoice)
    po.received = False
    db.session.commit()
    flash("Invoice reversed successfully", "success")
    return redirect(url_for("purchase.view_purchase_orders"))
